// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"github.com/getsentry/sentry-go"
	"github.com/google/wire"
	"github.com/gorilla/mux"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/auth"
	redis2 "github.com/skygeario/skygear-server/pkg/auth/dependency/auth/redis"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/authenticator/password"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/identity/anonymous"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/identity/loginid"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/identity/oauth"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/identity/provider"
	session2 "github.com/skygeario/skygear-server/pkg/auth/dependency/session"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/session/redis"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/user"
	"github.com/skygeario/skygear-server/pkg/auth/dependency/webapp"
	"github.com/skygeario/skygear-server/pkg/auth/handler/session"
	task2 "github.com/skygeario/skygear-server/pkg/auth/task"
	"github.com/skygeario/skygear-server/pkg/clock"
	"github.com/skygeario/skygear-server/pkg/core/rand"
	sentry2 "github.com/skygeario/skygear-server/pkg/core/sentry"
	"github.com/skygeario/skygear-server/pkg/db"
	"github.com/skygeario/skygear-server/pkg/deps"
	"github.com/skygeario/skygear-server/pkg/mail"
	"github.com/skygeario/skygear-server/pkg/middlewares"
	"github.com/skygeario/skygear-server/pkg/sms"
	"github.com/skygeario/skygear-server/pkg/task"
	"net/http"
)

// Injectors from wire_handler.go:

func newSessionResolveHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	config := appProvider.Config
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appConfig := config.AppConfig
	appID := appConfig.ID
	sqlBuilder := db.ProvideSQLBuilder(databaseCredentials, appID)
	context := appProvider.DbContext
	sqlExecutor := db.SQLExecutor{
		Context: context,
	}
	store := &anonymous.Store{
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	provider := &anonymous.Provider{
		Store: store,
	}
	factory := appProvider.LoggerFactory
	resolveHandlerLogger := session.NewResolveHandlerLogger(factory)
	resolveHandler := &session.ResolveHandler{
		Anonymous: provider,
		Logger:    resolveHandlerLogger,
	}
	return resolveHandler
}

// Injectors from wire_middleware.go:

func newSentryMiddleware(hub *sentry.Hub, p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	serverConfig := rootProvider.ServerConfig
	sentryMiddleware := &sentry2.Middleware{
		Hub:          hub,
		ServerConfig: serverConfig,
	}
	middlewareFunc := provideMiddlewareFunc(sentryMiddleware)
	return middlewareFunc
}

func newRecoverMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	recoveryLogger := middlewares.NewRecoveryLogger(factory)
	recoverMiddleware := &middlewares.RecoverMiddleware{
		Logger: recoveryLogger,
	}
	middlewareFunc := provideMiddlewareFunc(recoverMiddleware)
	return middlewareFunc
}

func newCORSMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	config := appProvider.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	corsMiddleware := &middlewares.CORSMiddleware{
		Config: httpConfig,
	}
	middlewareFunc := provideMiddlewareFunc(corsMiddleware)
	return middlewareFunc
}

func newCSPMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	config := appProvider.Config
	appConfig := config.AppConfig
	oAuthConfig := appConfig.OAuth
	cspMiddleware := &webapp.CSPMiddleware{
		Config: oAuthConfig,
	}
	middlewareFunc := provideMiddlewareFunc(cspMiddleware)
	return middlewareFunc
}

func newCSRFMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	config := appProvider.Config
	secretConfig := config.SecretConfig
	csrfKeyMaterials := deps.ProvideCSRFKeyMaterials(secretConfig)
	rootProvider := appProvider.RootProvider
	serverConfig := rootProvider.ServerConfig
	csrfMiddleware := &webapp.CSRFMiddleware{
		Secret: csrfKeyMaterials,
		Config: serverConfig,
	}
	middlewareFunc := provideMiddlewareFunc(csrfMiddleware)
	return middlewareFunc
}

func newAuthEntryPointMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	serverConfig := rootProvider.ServerConfig
	authEntryPointMiddleware := &webapp.AuthEntryPointMiddleware{
		ServerConfig: serverConfig,
	}
	middlewareFunc := provideMiddlewareFunc(authEntryPointMiddleware)
	return middlewareFunc
}

func newSessionMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	request := p.Request
	appProvider := p.AppProvider
	config := appProvider.Config
	appConfig := config.AppConfig
	sessionConfig := appConfig.Session
	rootProvider := appProvider.RootProvider
	serverConfig := rootProvider.ServerConfig
	cookieDef := session2.NewSessionCookieDef(request, sessionConfig, serverConfig)
	context := appProvider.RedisContext
	appID := appConfig.ID
	clock := _wireSystemClockValue
	factory := appProvider.LoggerFactory
	logger := redis.NewLogger(factory)
	store := &redis.Store{
		Redis:  context,
		AppID:  appID,
		Clock:  clock,
		Logger: logger,
	}
	eventStore := &redis2.EventStore{
		Redis: context,
		AppID: appID,
	}
	accessEventProvider := &auth.AccessEventProvider{
		Store: eventStore,
	}
	rand := _wireRandValue
	sessionProvider := &session2.Provider{
		Request:      request,
		Store:        store,
		AccessEvents: accessEventProvider,
		ServerConfig: serverConfig,
		Config:       sessionConfig,
		Clock:        clock,
		Random:       rand,
	}
	resolver := &session2.Resolver{
		Cookie:   cookieDef,
		Provider: sessionProvider,
		Config:   serverConfig,
		Clock:    clock,
	}
	authAccessEventProvider := auth.AccessEventProvider{
		Store: eventStore,
	}
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilder := db.ProvideSQLBuilder(databaseCredentials, appID)
	dbContext := appProvider.DbContext
	sqlExecutor := db.SQLExecutor{
		Context: dbContext,
	}
	userStore := &user.Store{
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	reservedNameChecker := rootProvider.ReservedNameChecker
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:              loginIDConfig,
		ReservedNameChecker: reservedNameChecker,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
	}
	oauthStore := &oauth.Store{
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	oauthProvider := &oauth.Provider{
		Store: oauthStore,
		Clock: clock,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
	}
	providerProvider := &provider.Provider{
		Authentication: authenticationConfig,
		Identity:       identityConfig,
		LoginID:        loginidProvider,
		OAuth:          oauthProvider,
		Anonymous:      anonymousProvider,
	}
	queries := &user.Queries{
		Store:      userStore,
		Identities: providerProvider,
	}
	authMiddleware := &auth.Middleware{
		IDPSessionResolver:         resolver,
		AccessTokenSessionResolver: resolver,
		AccessEvents:               authAccessEventProvider,
		Users:                      queries,
		DBContext:                  dbContext,
	}
	middlewareFunc := provideMiddlewareFunc(authMiddleware)
	return middlewareFunc
}

var (
	_wireSystemClockValue = clock.NewSystemClock()
	_wireRandValue        = session2.Rand(rand.SecureRand)
)

func newWebAppStateMiddleware(p *deps.RequestProvider) mux.MiddlewareFunc {
	appProvider := p.AppProvider
	context := appProvider.RedisContext
	stateStoreImpl := &webapp.StateStoreImpl{
		Redis: context,
	}
	stateMiddleware := &webapp.StateMiddleware{
		StateStore: stateStoreImpl,
	}
	middlewareFunc := provideMiddlewareFunc(stateMiddleware)
	return middlewareFunc
}

// Injectors from wire_task.go:

func newPwHousekeeperTask(p *deps.TaskProvider) task.Task {
	appProvider := p.AppProvider
	context := appProvider.DbContext
	factory := appProvider.LoggerFactory
	pwHousekeeperLogger := task2.NewPwHousekeeperLogger(factory)
	clockClock := _wireSystemClockValue
	config := appProvider.Config
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appConfig := config.AppConfig
	appID := appConfig.ID
	sqlBuilder := db.ProvideSQLBuilder(databaseCredentials, appID)
	sqlExecutor := db.SQLExecutor{
		Context: context,
	}
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilder,
		SQLExecutor: sqlExecutor,
	}
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	pwHousekeeperTask := &task2.PwHousekeeperTask{
		DBContext:     context,
		Logger:        pwHousekeeperLogger,
		PwHousekeeper: housekeeper,
	}
	return pwHousekeeperTask
}

func newSendMessagesTask(p *deps.TaskProvider) task.Task {
	appProvider := p.AppProvider
	config := appProvider.Config
	appConfig := config.AppConfig
	localizationConfig := appConfig.Localization
	secretConfig := config.SecretConfig
	smtpServerCredentials := deps.ProvideSMTPServerCredentials(secretConfig)
	dialer := mail.NewGomailDialer(smtpServerCredentials)
	context := appProvider.Context
	sender := &mail.Sender{
		LocalizationConfiguration: localizationConfig,
		GomailDialer:              dialer,
		Context:                   context,
	}
	messagingConfig := appConfig.Messaging
	twilioCredentials := deps.ProvideTwilioCredentials(secretConfig)
	twilioClient := sms.NewTwilioClient(twilioCredentials)
	nexmoCredentials := deps.ProvideNexmoCredentials(secretConfig)
	nexmoClient := sms.NewNexmoClient(nexmoCredentials)
	client := &sms.Client{
		Context:            context,
		MessagingConfig:    messagingConfig,
		LocalizationConfig: localizationConfig,
		TwilioClient:       twilioClient,
		NexmoClient:        nexmoClient,
	}
	factory := appProvider.LoggerFactory
	sendMessagesLogger := task2.NewSendMessagesLogger(factory)
	sendMessagesTask := &task2.SendMessagesTask{
		EmailSender: sender,
		SMSClient:   client,
		Logger:      sendMessagesLogger,
	}
	return sendMessagesTask
}

// wire_middleware.go:

type middleware interface {
	Handle(next http.Handler) http.Handler
}

func provideMiddlewareFunc(m middleware) mux.MiddlewareFunc { return m.Handle }

var middlewareDependencySet = wire.NewSet(deps.RequestDependencySet, provideMiddlewareFunc)

func newSentryMiddlewareFactory(hub *sentry.Hub) func(*deps.RequestProvider) mux.MiddlewareFunc {
	return func(p *deps.RequestProvider) mux.MiddlewareFunc {
		return newSentryMiddleware(hub, p)
	}
}
